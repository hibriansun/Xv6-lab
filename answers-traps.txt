# More details:
https://briansun.feishu.cn/docs/doccnP3rdlWaQI7qsJXVmINMnEc

# Which registers contain arguments to functions? For example, which register holds 13 in main's call to printf?
Answer:
* Register a0 - a7 can be used to pass functions' arguments. (Not on the stack, an argument is only passed via the stack if there is no room in the a* registers left.)
  a0 a1 also is able to store return values from functions.

* a2 holds the parameter 13. (24: 4635     li a2,13)


# Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)
* auipc make rooms for jalr. jalr jumps and links to register
  4e:	00000097          	auipc	ra,0x0
  52:	fce080e7          	jalr	-50(ra) # 1c <f>

* 30:	00000097          	auipc	ra,0x0
  34:	fd0080e7          	jalr	-48(ra) # 0 <g>


# At what address is the function printf located?
* 0000000000000630 <printf>

# What value is in the register ra just after the jalr to printf in main?
* PC+4 = 0x38


# Run the following code.

	unsigned int i = 0x00646c72;
	printf("H%x Wo%s", 57616, &i);
      
What is the output? Here's an ASCII table that maps bytes to characters.
The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?

Here's a description of little- and big-endian and a more whimsical description.

Answer:
* He110 World

Description:
* 57616 is decimal number, but we print it in hexadecimal format -- 0xe110.
* Split 0x646c72 into 0x64 0x6c 0x72 map d l r.
  Little-endian is combianed-byte data orginization in memory. High address <--> High endian of data    Low address <--> Low endian of data
  RISC-V is little-endian.
  Therefore:
  d -- High address
  l
  r -- Low address

  We print bytes from the low address to the high address.


# In the following code, what is going to be printed after 'y='? (note: the answer is not a specific value.) Why does this happen?

	printf("x=%d y=%d", 3);

Answer:
* We pass function parameters by a* registers. 
  The 2nd parameter is passed by a `aX` register.
  y is not a specific value because of the unspecific aX register.